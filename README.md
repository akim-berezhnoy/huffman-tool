# Huffman algorithm

Вам необходимо реализовать библиотеку и утилиту для сжатия с помощью алгоритма Хаффмана.

Ваш репозиторий должен состоять из двух частей:

1. Библиотека, реализующая алгоритмы сжатия и распаковки;
2. Утилита, которая сжимает или распаковывает файлы на диске с помощью вашей библиотеки.

## Требования к библиотеке

* Библиотека должна компилироваться в отдельную статическую либо динамическую библиотеку.
  И не должна зависеть ни от каких функций, определенных в коде вашего приложения или тестов.
* Библиотека должна предоставлять функционал сжатия и распаковки с помощью некоторых потоков данных
  (можно посмотреть в сторону `iostream` или *ZSTD streaming*). Данный подход помогает удобным образом организовать
  тестирование, позволяя реализовать эти "потоки" поверх обычных массивов байтиков.
* Библиотека не должна использовать функции для работы с файлами напрямую (а пользоваться абстракцией в виде
  стримов).
* Интерфейс библиотеки должен быть достаточен, чтобы консольная утилита могла сжать/распаковать файл, размером
  превосходящий размер доступной оперативной памяти.
* Библиотека должна быть покрыта тестами (см. подробности ниже).

## Требования к утилите

* Название исполняемого файла должно быть `huffman-tool`. Это нужно для запуска интеграционных тестов.
* Ваша утилита должна предоставлять интерфейс для работы с ней из консоли со следующими ключами запуска:
    * `--compress` и `--decompress` &mdash; для указания режима работы;
    * `--input <input-file>` &mdash; указание пути входного файла;
    * `--output <output-file>` &mdash; указание пути итогового файла;
    * `--help` с описанием всех ваших ключей и тем как пользоваться вашей утилитой (вдруг вы решите добавить свои).
* С помощью консольной утилиты должно быть возможно сжать один файл, записав в другой его сжатое представление, а также
  распаковать файл со сжатым представлением, получив исходный файл.
* Попытка сжать пустой файл это не ошибка. Должен получаться некоторый файл на выходе, при распаковке которого получится
  пустой файл.
* Консольная утилита должна работать в случае, когда выходной и/или выходной файлы превосходят размер доступной
  оперативной памяти.
* Если распаковываемый файл повреждён, возникла неожиданная проблема с вводом/выводом или любая подобная проблема,
  утилита должна выводить сообщение об ошибке в стандартный поток ошибок (`stderr`) и завершаться с ненулевым кодом.

## Требования к тестам

* Вы должны покрыть юнит- или компонентными тестами весь публичный функционал вашей библиотеки.
  Тестирование приватных функций, а также самой утилиты не обязательно, но будет являться плюсом.
* Обеспечьте максимальное покрытие тестами кода вашей библиотеки
  (можно померить с помощью gcov, lcov или чего-то ещё, есть даже интеграция с CLion).
* Ваши тесты должны запускаться в CI. Для этого потребуется изучить и возможно модифицировать
  [конфиг CI](.github/workflows/cpp.yml) и/или используемые им скрипты.
  Также вам потребуется разобраться с конфигурацией CMake.

## Рекомендации

* Задание творческое, поэтому сначала тщательно продумайте архитектуру своего решения, прежде чем начать его
  реализовывать.
* В этом задании будет учитываться производительность вашего кода.
  Для оптимизации и поиска узких мест советуем пользоваться различными профилировщиками, например, `perf`.
* Почти всегда работа с файлами без буферизации приводит к просадкам по производительности.
  Проследите, чтобы ваш или используемый вами код использовал эту технику.
* Читать и записывать по одному битику даже при буферизации будет скорее всего медленно.
* Кроме скорости работы также учитывается качество сжатия. Стоит подумать над тем, как хранить на диске данные,
  необходимые для разжатия. Их неэффективная сериализация может привести к тому, что не слишком большие, но хорошо
  сжимаемые файлы по итогу будут иметь размер, сопоставимый с исходным и даже более.
* У вас есть *vcpkg*, с помощью которого вы можете подключать любые библиотеки, повышающие ваше удобство.
  (например, библиотека для парсинга опций командной строки). При этом запрещается использовать библиотеки, которые
  полностью реализуют данную утилиту или алгоритм. К тому же нужно быть готовым обосновать выбор используемой
  библиотеки, так что подумайте дважды, прежде чем затягивать весь `Boost` в ваш проект.
